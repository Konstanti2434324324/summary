1) Чем отличаются == и is? == Отвечает на вопрос равны ли значения обьектов. Is проверяет указывают ли они на один обьект в памяти
a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(a == b) # True – содержимое списков одинаково
print(a is b) # False – это разные объекты в памяти
print(a is c) # True – обе переменные указывают на один объект

2) @classmethod и @staticmethod - Обычные методы, как правило, вызываются из экземпляров классов и работают с атрибутами
экземпляров и атрибутами классов. Методы классов обычно вызываются через класс, реже через его экземпляры и имеют доступ
только к атрибутам самого класса, в котором объявлены. Наконец, статические методы – это совершенно изолированные функции,
которые работают только с параметрами, прописанными в ней самой и не имеют доступа к атрибутам класса или его экземпляров.

Поэтому, если вам нужен метод, который работает с атрибутами объектов класса, то это обычное определение функций внутри 
класса с первым параметром self. Если метод работает только с атрибутами класса, то возможно, имеет смысл его определить
как метод класса и тогда можно будет вызывать без ссылки на объект этого класса. Третий тип, статические методы часто 
определяют как вспомогательные, сервисные, связанные с логикой работы самого класса.

3) Принципы работы Pandas - 
Series — это одномерный массив данных, который может содержать любой тип данных
(целые числа, строки, числа с плавающей точкой, объекты Python и т. д.). Каждому элементу в Series соответствует метка, которая называется индексом. 
DataFrame — это двумерная структура данных, похожая на таблицу в SQL или на лист в Excel. DataFrame поддерживает столбцы различных типов данных, 
что очень удобно для задач по обработке данных, включая статистический анализ, очистку данных, а также их визуализацию.

4) Принципы работы Celery и Redis

5) Docker и Docker Compose

6) Scrum 

7) Чем генераторы отличаются от списковых ключей 

8) Генераторы и итераторы

9) как работает Deep copy

10) почему Fast api быстрее из коробки чем Django или Flask 

11) Асинхронность и многопоточность 

12) Pydantic - зачем нужен 

13) BaseModel 

14) Swagger 

SQL 
15) что такое SQL alchimi и ORM

16) INNER JOIN, LEFT JOIN, RIGHT JOIN

17) как найти уникальные значения в столбце 

18) Зачем нужен limit

19) Зачем нужен 

20) Что такое иденпотентность

21) Методы REST

22) GIL: что это и когда мешает

23) async/await: что реально дает, где подводные камни

24) threading vs multiprocessing vs asyncio

25) Context manager, генераторы, итераторы

26) MRO, dataclass, typing/mypy — зачем

27) HTTP методы, идемпотентность, коды ошибок

28) JWT vs session, refresh tokens, CSRF

29) Валидация входа, схемы, версионирование API

30)DB индексы и EXPLAIN

31) Транзакции и уровни изоляции

32) Deadlock: почему и что делать

33) N+1: где возникает и как лечить

34) Redis cache-aside, TTL, stampede

35) Rate limiting: подходы и хранение счетчиков

36) Очереди: гарантия доставки, ретраи, DLQ

37) Идемпотентность воркера/эндпойнта

38)Монолит vs микросервисы — когда что

39) Observability: logs/metrics/traces, correlation id

40) Graceful shutdown, timeouts, retries

41) Пулы соединений к БД, лимиты

42) Pagination: offset vs cursor

43) Обработка ошибок и контракт API

44) Тесты: unit/integration, фикстуры, мокинг

45) Безопасность: SQLi, XSS (в контексте API), secrets management

46) Производительность: где мерить, как профилировать

47) 

